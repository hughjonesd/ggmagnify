% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geom-magnify.R, R/geom-magnify-tile.R
\name{geom_magnify}
\alias{geom_magnify}
\alias{geom_magnify_tile}
\title{Magnified inset of a plot}
\usage{
geom_magnify(
  mapping = NULL,
  data = NULL,
  stat = StatMagnify,
  position = "identity",
  ...,
  expand = 0.1,
  aspect = c("free", "fixed"),
  axes = "",
  proj = c("facing", "corresponding", "single"),
  shadow = FALSE,
  colour = "black",
  linetype = 1,
  target.linetype = linetype,
  inset.linetype = linetype,
  proj.linetype = 2,
  alpha = 1,
  linewidth = 0.4,
  shape = c("rect", "ellipse", "hull", "map"),
  plot = NULL,
  shadow.args = list(sigma = 5, colour = "grey40", x_offset = 5, y_offset = 5),
  recompute = FALSE,
  scale.inset = 1,
  na.rm = FALSE,
  inherit.aes = TRUE
)

geom_magnify_tile(
  mapping = NULL,
  data = NULL,
  stat = StatMagnifyTile,
  position = "identity",
  ...,
  expand = 0.1,
  aspect = c("free", "fixed"),
  axes = "",
  proj = "facing",
  shadow = FALSE,
  colour = "black",
  linetype = 1,
  target.linetype = linetype,
  inset.linetype = linetype,
  proj.linetype = 2,
  alpha = 1,
  linewidth = 0.4,
  shape = "rect",
  plot = NULL,
  shadow.args = list(sigma = 5, colour = "grey40", x_offset = 5, y_offset = 5),
  recompute = FALSE,
  scale.inset = 1,
  na.rm = FALSE,
  inherit.aes = FALSE
)
}
\arguments{
\item{mapping, data, stat, position, ..., na.rm}{See e.g. \code{\link[ggplot2:geom_point]{ggplot2::geom_point()}}.}

\item{expand}{Number. Expand the target area and inset proportionally
by this amount.}

\item{aspect}{String. \code{"fixed"} to fix the aspect ratio (overrides \code{ymax}).}

\item{axes}{String. Which axes to plot in the inset? \code{""}, \code{"x"}, \code{"y"} or
\code{"xy"}.}

\item{proj}{String. What style of projection lines to draw? \code{"facing"} (the
default), \code{"corresponding"} or \code{"single"}. Can be abbreviated. See below.}

\item{shadow}{Logical. Draw a shadow behind the inset plot? Requires the
"ggfx" package.}

\item{linetype, colour, alpha, linewidth}{Linetype, colour, alpha and linewidth
for borders and projection lines.}

\item{target.linetype, inset.linetype, proj.linetype}{Linetypes
for specific components. Set to \code{0} for no lines.}

\item{shape}{Shape of the area to be magnified. \code{"rect"} for a rectangle.
\code{"ellipse"} for an ellipse. \code{"hull"} for the convex hull of a set of points.
\code{"map"} for a map area. See below.}

\item{plot}{Ggplot object to plot in the inset. If \code{NULL}, defaults to the
ggplot object to which \code{geom_magnify()} is added.}

\item{shadow.args}{List. Arguments to \code{\link[ggfx:with_shadow]{ggfx::with_shadow()}}.}

\item{recompute}{Logical. If \code{TRUE}, use \link[ggplot2:lims]{lims()} to
replot the inset. Statistics, e.g. smoothing lines, will be
recomputed using only the data in the target area. If \code{FALSE}, use
\link[ggplot2:coord_cartesian]{coord_cartesian()} to replot the inset,
keeping all the data.}

\item{scale.inset}{Length 1 or 2 numeric. Normally, exactly the target area
is shown on the inset. Sometimes you may wish to rescale the plot in the
inset. Use 2 numbers to scale width and height separately.}

\item{inherit.aes}{If \code{FALSE}, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. \code{\link[ggplot2:borders]{borders()}}.}
}
\description{
\code{geom_magnify()} creates a magnified inset of part of a plot. Optional
borders are drawn around the target and inset, along with projection lines
from one to the other.
}
\details{
\subsection{Aesthetics}{

geom_magnify understand the following aesthetics (required aesthetics are in
bold):
\itemize{
\item \strong{from}
\item \strong{to}
}

\code{from} and \code{to} can be lists of length 4, like \code{list(xmin, ymin, xmax, ymax)}.
These specify the bottom left and top right corners of the target area to
magnify, and the area for the magnified inset. The lists can optionally be
named, like this: \code{list(xmin = 1, ymin = 2, xmax = 3, ymax = 4)}.

Alternatively, \code{from} can be:
\itemize{
\item A data frame of points with two columns for \code{x} and \code{y}. These points will
be surrounded by a rectangle, ellipse or convex hull depending on the
value of \code{shape}.
\item A \code{\link[grid:grid.grob]{grid::grob()}} object. This will be used as a mask. Points should be
on the same scale as the data, with \code{default.units = "native"} in the grob.
Note that only single polygons are supported at the moment. \code{shape} will
be ignored.
\item A logical vector. Points in the data where \code{from} is \code{TRUE} will be
surrounded by a rectangle, ellipse or convex hull.
}

Normally you'll set \code{from} and \code{to} in the call to \code{geom_magnify()}. You can
specify them as aesthetics, e.g. if you want different areas per facet. If
so, you need to wrap them in a \code{\link[=list]{list()}} to make sure they are length one
per row of data. Only the first row is used per panel.

Note that only one area gets magnified per panel. To magnify multiple areas,
use multiple calls to \code{geom_magnify()}.
}

\subsection{Projection lines}{

\code{proj = "corresponding"} or \code{"facing"} draws projection lines from the
corners of the target to the corners of the inset. \code{"corresponding"} always
projects each corner of the target to the same corner of the inset.
\code{"facing"} sometimes draws lines between facing corners, when this looks
cleaner. \code{"single"} draws a single line from the midpoint of facing sides.
Unless \code{from} is \code{"rect"}, \code{"facing"} and
\code{"corresponding"} are the same.

To draw no lines, set \code{proj.linetype = 0}.
}

\subsection{Limitations}{
\itemize{
\item \code{geom_magnify()} uses masks. This requires R version 4.1.0 or higher, and
a graphics device that supports masking. If you are using knitr, you may have
luck with the \code{ragg_png} device.
\item \code{geom_magnify()} uses dark magic to deal with faceting. It may break with
older, or newer, versions of ggplot2. If you don't need faceting, and want
your code to be robust to upgrades, set \code{options(ggmagnify.safe_mode = TRUE)}
to use slightly less magic.
\item By design, \code{geom_magnify()} replots the original plot using new limits. It
does not directly copy the target area pixels. The advantage is that you can
e.g. add axes, plot points at an appropriate size, zoom in on data that's
invisible in the main plot, or recompute derived graphics. If you want an
exact pixel-by-pixel copy, use a different tool.
\item \code{geom_magnify()} may break with discrete scales. This is a limitation in
ggplot2 for now.
}
}

\code{geom_magnify_tile()} is a version of \code{geom_magnify()} which uses different
aesthetics. Set \code{x}, \code{width}, \code{y}, \code{height} and \code{to_x}, \code{to_width} \code{to_y},
\code{to_height} to specify the target and inset location.
}
\examples{
library(ggplot2)
ggp <- ggplot(iris, aes(Sepal.Width, Sepal.Length, colour = Species)) +
         geom_point() + xlim(c(2, 6))

# Basic magnification
ggp + geom_magnify(from = c(3, 6.5, 4, 7.5),
                     to = c(4, 5, 7, 6.5))

# Ellipse magnification
if (getRversion() >= 4.2) {
  ggp + geom_magnify(from = c(3, 6.5, 4, 7.5),
                     to = c(4, 5, 7, 6.5), shape = "ellipse")
}

# Shadow
if (requireNamespace("ggfx", quietly = TRUE)) {
  ggp + geom_magnify(from = c(3, 6.5, 4, 7.5),
                     to = c(4, 5, 7, 6.5), shadow = TRUE)
}

# Convex hull of points
ggplot(iris, aes(Sepal.Width, Sepal.Length, colour = Species)) +
       geom_point() + xlim(c(2, 5)) +
       geom_magnify(aes(from = Species == "setosa"), to = c(3, 6, 5, 8),
                    shape = "hull")

# Order matters

# `geom_magnify()` stores the plot when it is added to it:
ggp +
  geom_smooth() +
  geom_magnify(from = c(3, 6.5, 4, 7.5),
               to = c(4, 5, 7, 6.5))

# This will print the inset without the smooth:
ggp +
  geom_magnify(from = c(3, 6.5, 4, 7.5),
               to = c(4, 5, 7, 6.5)) +
  geom_smooth()
}
